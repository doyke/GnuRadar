// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Control.proto

#ifndef PROTOBUF_Control_2eproto__INCLUDED
#define PROTOBUF_Control_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace gnuradar {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Control_2eproto();
void protobuf_AssignDesc_Control_2eproto();
void protobuf_ShutdownFile_Control_2eproto();

class Channel;
class ControlMessage;
class File;
class RadarParameters;
class Window;

// ===================================================================

class ControlMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnuradar.ControlMessage) */ {
 public:
  ControlMessage();
  virtual ~ControlMessage();

  ControlMessage(const ControlMessage& from);

  inline ControlMessage& operator=(const ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlMessage& default_instance();

  void Swap(ControlMessage* other);

  // implements Message ----------------------------------------------

  inline ControlMessage* New() const { return New(NULL); }

  ControlMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlMessage& from);
  void MergeFrom(const ControlMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ControlMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .gnuradar.File file = 2;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 2;
  const ::gnuradar::File& file() const;
  ::gnuradar::File* mutable_file();
  ::gnuradar::File* release_file();
  void set_allocated_file(::gnuradar::File* file);

  // @@protoc_insertion_point(class_scope:gnuradar.ControlMessage)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_file();
  inline void clear_has_file();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::gnuradar::File* file_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static ControlMessage* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnuradar.File) */ {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  void Swap(File* other);

  // implements Message ----------------------------------------------

  inline File* New() const { return New(NULL); }

  File* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // required float sampleRate = 2;
  bool has_samplerate() const;
  void clear_samplerate();
  static const int kSampleRateFieldNumber = 2;
  float samplerate() const;
  void set_samplerate(float value);

  // required int32 decimation = 3;
  bool has_decimation() const;
  void clear_decimation();
  static const int kDecimationFieldNumber = 3;
  ::google::protobuf::int32 decimation() const;
  void set_decimation(::google::protobuf::int32 value);

  // required int32 numChannels = 4;
  bool has_numchannels() const;
  void clear_numchannels();
  static const int kNumChannelsFieldNumber = 4;
  ::google::protobuf::int32 numchannels() const;
  void set_numchannels(::google::protobuf::int32 value);

  // required float bandwidth = 5;
  bool has_bandwidth() const;
  void clear_bandwidth();
  static const int kBandwidthFieldNumber = 5;
  float bandwidth() const;
  void set_bandwidth(float value);

  // required string bandwidthUnits = 6;
  bool has_bandwidthunits() const;
  void clear_bandwidthunits();
  static const int kBandwidthUnitsFieldNumber = 6;
  const ::std::string& bandwidthunits() const;
  void set_bandwidthunits(const ::std::string& value);
  void set_bandwidthunits(const char* value);
  void set_bandwidthunits(const char* value, size_t size);
  ::std::string* mutable_bandwidthunits();
  ::std::string* release_bandwidthunits();
  void set_allocated_bandwidthunits(::std::string* bandwidthunits);

  // required int32 numWindows = 7;
  bool has_numwindows() const;
  void clear_numwindows();
  static const int kNumWindowsFieldNumber = 7;
  ::google::protobuf::int32 numwindows() const;
  void set_numwindows(::google::protobuf::int32 value);

  // required float pri = 8;
  bool has_pri() const;
  void clear_pri();
  static const int kPriFieldNumber = 8;
  float pri() const;
  void set_pri(float value);

  // required string priUnits = 9;
  bool has_priunits() const;
  void clear_priunits();
  static const int kPriUnitsFieldNumber = 9;
  const ::std::string& priunits() const;
  void set_priunits(const ::std::string& value);
  void set_priunits(const char* value);
  void set_priunits(const char* value, size_t size);
  ::std::string* mutable_priunits();
  ::std::string* release_priunits();
  void set_allocated_priunits(::std::string* priunits);

  // required float txCarrier = 10;
  bool has_txcarrier() const;
  void clear_txcarrier();
  static const int kTxCarrierFieldNumber = 10;
  float txcarrier() const;
  void set_txcarrier(float value);

  // required string organization = 11;
  bool has_organization() const;
  void clear_organization();
  static const int kOrganizationFieldNumber = 11;
  const ::std::string& organization() const;
  void set_organization(const ::std::string& value);
  void set_organization(const char* value);
  void set_organization(const char* value, size_t size);
  ::std::string* mutable_organization();
  ::std::string* release_organization();
  void set_allocated_organization(::std::string* organization);

  // required string site = 12;
  bool has_site() const;
  void clear_site();
  static const int kSiteFieldNumber = 12;
  const ::std::string& site() const;
  void set_site(const ::std::string& value);
  void set_site(const char* value);
  void set_site(const char* value, size_t size);
  ::std::string* mutable_site();
  ::std::string* release_site();
  void set_allocated_site(::std::string* site);

  // required string user = 13;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 13;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // required string radar = 14;
  bool has_radar() const;
  void clear_radar();
  static const int kRadarFieldNumber = 14;
  const ::std::string& radar() const;
  void set_radar(const ::std::string& value);
  void set_radar(const char* value);
  void set_radar(const char* value, size_t size);
  ::std::string* mutable_radar();
  ::std::string* release_radar();
  void set_allocated_radar(::std::string* radar);

  // required string receiver = 15;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 15;
  const ::std::string& receiver() const;
  void set_receiver(const ::std::string& value);
  void set_receiver(const char* value);
  void set_receiver(const char* value, size_t size);
  ::std::string* mutable_receiver();
  ::std::string* release_receiver();
  void set_allocated_receiver(::std::string* receiver);

  // required string fpgaImage = 16;
  bool has_fpgaimage() const;
  void clear_fpgaimage();
  static const int kFpgaImageFieldNumber = 16;
  const ::std::string& fpgaimage() const;
  void set_fpgaimage(const ::std::string& value);
  void set_fpgaimage(const char* value);
  void set_fpgaimage(const char* value, size_t size);
  ::std::string* mutable_fpgaimage();
  ::std::string* release_fpgaimage();
  void set_allocated_fpgaimage(::std::string* fpgaimage);

  // required string baseFileName = 17;
  bool has_basefilename() const;
  void clear_basefilename();
  static const int kBaseFileNameFieldNumber = 17;
  const ::std::string& basefilename() const;
  void set_basefilename(const ::std::string& value);
  void set_basefilename(const char* value);
  void set_basefilename(const char* value, size_t size);
  ::std::string* mutable_basefilename();
  ::std::string* release_basefilename();
  void set_allocated_basefilename(::std::string* basefilename);

  // optional float outputRate = 18;
  bool has_outputrate() const;
  void clear_outputrate();
  static const int kOutputRateFieldNumber = 18;
  float outputrate() const;
  void set_outputrate(float value);

  // repeated .gnuradar.Channel channel = 19;
  int channel_size() const;
  void clear_channel();
  static const int kChannelFieldNumber = 19;
  const ::gnuradar::Channel& channel(int index) const;
  ::gnuradar::Channel* mutable_channel(int index);
  ::gnuradar::Channel* add_channel();
  ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >*
      mutable_channel();
  const ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >&
      channel() const;

  // repeated .gnuradar.Window window = 20;
  int window_size() const;
  void clear_window();
  static const int kWindowFieldNumber = 20;
  const ::gnuradar::Window& window(int index) const;
  ::gnuradar::Window* mutable_window(int index);
  ::gnuradar::Window* add_window();
  ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >*
      mutable_window();
  const ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >&
      window() const;

  // optional .gnuradar.RadarParameters radarParameters = 21;
  bool has_radarparameters() const;
  void clear_radarparameters();
  static const int kRadarParametersFieldNumber = 21;
  const ::gnuradar::RadarParameters& radarparameters() const;
  ::gnuradar::RadarParameters* mutable_radarparameters();
  ::gnuradar::RadarParameters* release_radarparameters();
  void set_allocated_radarparameters(::gnuradar::RadarParameters* radarparameters);

  // @@protoc_insertion_point(class_scope:gnuradar.File)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_decimation();
  inline void clear_has_decimation();
  inline void set_has_numchannels();
  inline void clear_has_numchannels();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_bandwidthunits();
  inline void clear_has_bandwidthunits();
  inline void set_has_numwindows();
  inline void clear_has_numwindows();
  inline void set_has_pri();
  inline void clear_has_pri();
  inline void set_has_priunits();
  inline void clear_has_priunits();
  inline void set_has_txcarrier();
  inline void clear_has_txcarrier();
  inline void set_has_organization();
  inline void clear_has_organization();
  inline void set_has_site();
  inline void clear_has_site();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_radar();
  inline void clear_has_radar();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_fpgaimage();
  inline void clear_has_fpgaimage();
  inline void set_has_basefilename();
  inline void clear_has_basefilename();
  inline void set_has_outputrate();
  inline void clear_has_outputrate();
  inline void set_has_radarparameters();
  inline void clear_has_radarparameters();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  float samplerate_;
  ::google::protobuf::int32 decimation_;
  ::google::protobuf::int32 numchannels_;
  float bandwidth_;
  ::google::protobuf::internal::ArenaStringPtr bandwidthunits_;
  ::google::protobuf::int32 numwindows_;
  float pri_;
  ::google::protobuf::internal::ArenaStringPtr priunits_;
  ::google::protobuf::internal::ArenaStringPtr organization_;
  ::google::protobuf::internal::ArenaStringPtr site_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr radar_;
  float txcarrier_;
  float outputrate_;
  ::google::protobuf::internal::ArenaStringPtr receiver_;
  ::google::protobuf::internal::ArenaStringPtr fpgaimage_;
  ::google::protobuf::internal::ArenaStringPtr basefilename_;
  ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel > channel_;
  ::google::protobuf::RepeatedPtrField< ::gnuradar::Window > window_;
  ::gnuradar::RadarParameters* radarparameters_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnuradar.Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();

  void Swap(Channel* other);

  // implements Message ----------------------------------------------

  inline Channel* New() const { return New(NULL); }

  Channel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float frequency = 1;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  float frequency() const;
  void set_frequency(float value);

  // required string frequencyUnits = 2;
  bool has_frequencyunits() const;
  void clear_frequencyunits();
  static const int kFrequencyUnitsFieldNumber = 2;
  const ::std::string& frequencyunits() const;
  void set_frequencyunits(const ::std::string& value);
  void set_frequencyunits(const char* value);
  void set_frequencyunits(const char* value, size_t size);
  ::std::string* mutable_frequencyunits();
  ::std::string* release_frequencyunits();
  void set_allocated_frequencyunits(::std::string* frequencyunits);

  // required float phase = 3;
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 3;
  float phase() const;
  void set_phase(float value);

  // required string phaseUnits = 4;
  bool has_phaseunits() const;
  void clear_phaseunits();
  static const int kPhaseUnitsFieldNumber = 4;
  const ::std::string& phaseunits() const;
  void set_phaseunits(const ::std::string& value);
  void set_phaseunits(const char* value);
  void set_phaseunits(const char* value, size_t size);
  ::std::string* mutable_phaseunits();
  ::std::string* release_phaseunits();
  void set_allocated_phaseunits(::std::string* phaseunits);

  // @@protoc_insertion_point(class_scope:gnuradar.Channel)
 private:
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_frequencyunits();
  inline void clear_has_frequencyunits();
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_phaseunits();
  inline void clear_has_phaseunits();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr frequencyunits_;
  float frequency_;
  float phase_;
  ::google::protobuf::internal::ArenaStringPtr phaseunits_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static Channel* default_instance_;
};
// -------------------------------------------------------------------

class Window : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnuradar.Window) */ {
 public:
  Window();
  virtual ~Window();

  Window(const Window& from);

  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Window& default_instance();

  void Swap(Window* other);

  // implements Message ----------------------------------------------

  inline Window* New() const { return New(NULL); }

  Window* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Window& from);
  void MergeFrom(const Window& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Window* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required float start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  float start() const;
  void set_start(float value);

  // required float stop = 3;
  bool has_stop() const;
  void clear_stop();
  static const int kStopFieldNumber = 3;
  float stop() const;
  void set_stop(float value);

  // optional float width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  float width() const;
  void set_width(float value);

  // required string units = 5;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 5;
  const ::std::string& units() const;
  void set_units(const ::std::string& value);
  void set_units(const char* value);
  void set_units(const char* value, size_t size);
  ::std::string* mutable_units();
  ::std::string* release_units();
  void set_allocated_units(::std::string* units);

  // @@protoc_insertion_point(class_scope:gnuradar.Window)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_stop();
  inline void clear_has_stop();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_units();
  inline void clear_has_units();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  float start_;
  float stop_;
  ::google::protobuf::internal::ArenaStringPtr units_;
  float width_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static Window* default_instance_;
};
// -------------------------------------------------------------------

class RadarParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnuradar.RadarParameters) */ {
 public:
  RadarParameters();
  virtual ~RadarParameters();

  RadarParameters(const RadarParameters& from);

  inline RadarParameters& operator=(const RadarParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadarParameters& default_instance();

  void Swap(RadarParameters* other);

  // implements Message ----------------------------------------------

  inline RadarParameters* New() const { return New(NULL); }

  RadarParameters* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadarParameters& from);
  void MergeFrom(const RadarParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RadarParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 samplesPerPri = 1;
  bool has_samplesperpri() const;
  void clear_samplesperpri();
  static const int kSamplesPerPriFieldNumber = 1;
  ::google::protobuf::int32 samplesperpri() const;
  void set_samplesperpri(::google::protobuf::int32 value);

  // required int32 samplesPerBuffer = 2;
  bool has_samplesperbuffer() const;
  void clear_samplesperbuffer();
  static const int kSamplesPerBufferFieldNumber = 2;
  ::google::protobuf::int32 samplesperbuffer() const;
  void set_samplesperbuffer(::google::protobuf::int32 value);

  // required int32 bytesPerBuffer = 3;
  bool has_bytesperbuffer() const;
  void clear_bytesperbuffer();
  static const int kBytesPerBufferFieldNumber = 3;
  ::google::protobuf::int32 bytesperbuffer() const;
  void set_bytesperbuffer(::google::protobuf::int32 value);

  // required float bytesPerSecond = 4;
  bool has_bytespersecond() const;
  void clear_bytespersecond();
  static const int kBytesPerSecondFieldNumber = 4;
  float bytespersecond() const;
  void set_bytespersecond(float value);

  // required float pri = 5;
  bool has_pri() const;
  void clear_pri();
  static const int kPriFieldNumber = 5;
  float pri() const;
  void set_pri(float value);

  // required float prf = 6;
  bool has_prf() const;
  void clear_prf();
  static const int kPrfFieldNumber = 6;
  float prf() const;
  void set_prf(float value);

  // required int32 prisPerBuffer = 7;
  bool has_prisperbuffer() const;
  void clear_prisperbuffer();
  static const int kPrisPerBufferFieldNumber = 7;
  ::google::protobuf::int32 prisperbuffer() const;
  void set_prisperbuffer(::google::protobuf::int32 value);

  // required int32 bytesPerSample = 8;
  bool has_bytespersample() const;
  void clear_bytespersample();
  static const int kBytesPerSampleFieldNumber = 8;
  ::google::protobuf::int32 bytespersample() const;
  void set_bytespersample(::google::protobuf::int32 value);

  // required float secondsPerBuffer = 9;
  bool has_secondsperbuffer() const;
  void clear_secondsperbuffer();
  static const int kSecondsPerBufferFieldNumber = 9;
  float secondsperbuffer() const;
  void set_secondsperbuffer(float value);

  // @@protoc_insertion_point(class_scope:gnuradar.RadarParameters)
 private:
  inline void set_has_samplesperpri();
  inline void clear_has_samplesperpri();
  inline void set_has_samplesperbuffer();
  inline void clear_has_samplesperbuffer();
  inline void set_has_bytesperbuffer();
  inline void clear_has_bytesperbuffer();
  inline void set_has_bytespersecond();
  inline void clear_has_bytespersecond();
  inline void set_has_pri();
  inline void clear_has_pri();
  inline void set_has_prf();
  inline void clear_has_prf();
  inline void set_has_prisperbuffer();
  inline void clear_has_prisperbuffer();
  inline void set_has_bytespersample();
  inline void clear_has_bytespersample();
  inline void set_has_secondsperbuffer();
  inline void clear_has_secondsperbuffer();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 samplesperpri_;
  ::google::protobuf::int32 samplesperbuffer_;
  ::google::protobuf::int32 bytesperbuffer_;
  float bytespersecond_;
  float pri_;
  float prf_;
  ::google::protobuf::int32 prisperbuffer_;
  ::google::protobuf::int32 bytespersample_;
  float secondsperbuffer_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static RadarParameters* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ControlMessage

// required string name = 1;
inline bool ControlMessage::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlMessage::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlMessage::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ControlMessage::name() const {
  // @@protoc_insertion_point(field_get:gnuradar.ControlMessage.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ControlMessage::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.ControlMessage.name)
}
inline void ControlMessage::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.ControlMessage.name)
}
inline void ControlMessage::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.ControlMessage.name)
}
inline ::std::string* ControlMessage::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:gnuradar.ControlMessage.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ControlMessage::release_name() {
  // @@protoc_insertion_point(field_release:gnuradar.ControlMessage.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ControlMessage::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.ControlMessage.name)
}

// optional .gnuradar.File file = 2;
inline bool ControlMessage::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlMessage::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlMessage::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlMessage::clear_file() {
  if (file_ != NULL) file_->::gnuradar::File::Clear();
  clear_has_file();
}
inline const ::gnuradar::File& ControlMessage::file() const {
  // @@protoc_insertion_point(field_get:gnuradar.ControlMessage.file)
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::gnuradar::File* ControlMessage::mutable_file() {
  set_has_file();
  if (file_ == NULL) {
    file_ = new ::gnuradar::File;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.ControlMessage.file)
  return file_;
}
inline ::gnuradar::File* ControlMessage::release_file() {
  // @@protoc_insertion_point(field_release:gnuradar.ControlMessage.file)
  clear_has_file();
  ::gnuradar::File* temp = file_;
  file_ = NULL;
  return temp;
}
inline void ControlMessage::set_allocated_file(::gnuradar::File* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.ControlMessage.file)
}

// -------------------------------------------------------------------

// File

// required string version = 1;
inline bool File::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& File::version() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.version)
}
inline void File::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.version)
}
inline void File::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.version)
}
inline ::std::string* File::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_version() {
  // @@protoc_insertion_point(field_release:gnuradar.File.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.version)
}

// required float sampleRate = 2;
inline bool File::has_samplerate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_samplerate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline float File::samplerate() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.sampleRate)
  return samplerate_;
}
inline void File::set_samplerate(float value) {
  set_has_samplerate();
  samplerate_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.sampleRate)
}

// required int32 decimation = 3;
inline bool File::has_decimation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_decimation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_decimation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_decimation() {
  decimation_ = 0;
  clear_has_decimation();
}
inline ::google::protobuf::int32 File::decimation() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.decimation)
  return decimation_;
}
inline void File::set_decimation(::google::protobuf::int32 value) {
  set_has_decimation();
  decimation_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.decimation)
}

// required int32 numChannels = 4;
inline bool File::has_numchannels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_numchannels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_numchannels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_numchannels() {
  numchannels_ = 0;
  clear_has_numchannels();
}
inline ::google::protobuf::int32 File::numchannels() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.numChannels)
  return numchannels_;
}
inline void File::set_numchannels(::google::protobuf::int32 value) {
  set_has_numchannels();
  numchannels_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.numChannels)
}

// required float bandwidth = 5;
inline bool File::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void File::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void File::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void File::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline float File::bandwidth() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.bandwidth)
  return bandwidth_;
}
inline void File::set_bandwidth(float value) {
  set_has_bandwidth();
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.bandwidth)
}

// required string bandwidthUnits = 6;
inline bool File::has_bandwidthunits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void File::set_has_bandwidthunits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void File::clear_has_bandwidthunits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void File::clear_bandwidthunits() {
  bandwidthunits_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bandwidthunits();
}
inline const ::std::string& File::bandwidthunits() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.bandwidthUnits)
  return bandwidthunits_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_bandwidthunits(const ::std::string& value) {
  set_has_bandwidthunits();
  bandwidthunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.bandwidthUnits)
}
inline void File::set_bandwidthunits(const char* value) {
  set_has_bandwidthunits();
  bandwidthunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.bandwidthUnits)
}
inline void File::set_bandwidthunits(const char* value, size_t size) {
  set_has_bandwidthunits();
  bandwidthunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.bandwidthUnits)
}
inline ::std::string* File::mutable_bandwidthunits() {
  set_has_bandwidthunits();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.bandwidthUnits)
  return bandwidthunits_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_bandwidthunits() {
  // @@protoc_insertion_point(field_release:gnuradar.File.bandwidthUnits)
  clear_has_bandwidthunits();
  return bandwidthunits_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_bandwidthunits(::std::string* bandwidthunits) {
  if (bandwidthunits != NULL) {
    set_has_bandwidthunits();
  } else {
    clear_has_bandwidthunits();
  }
  bandwidthunits_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bandwidthunits);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.bandwidthUnits)
}

// required int32 numWindows = 7;
inline bool File::has_numwindows() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void File::set_has_numwindows() {
  _has_bits_[0] |= 0x00000040u;
}
inline void File::clear_has_numwindows() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void File::clear_numwindows() {
  numwindows_ = 0;
  clear_has_numwindows();
}
inline ::google::protobuf::int32 File::numwindows() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.numWindows)
  return numwindows_;
}
inline void File::set_numwindows(::google::protobuf::int32 value) {
  set_has_numwindows();
  numwindows_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.numWindows)
}

// required float pri = 8;
inline bool File::has_pri() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void File::set_has_pri() {
  _has_bits_[0] |= 0x00000080u;
}
inline void File::clear_has_pri() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void File::clear_pri() {
  pri_ = 0;
  clear_has_pri();
}
inline float File::pri() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.pri)
  return pri_;
}
inline void File::set_pri(float value) {
  set_has_pri();
  pri_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.pri)
}

// required string priUnits = 9;
inline bool File::has_priunits() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void File::set_has_priunits() {
  _has_bits_[0] |= 0x00000100u;
}
inline void File::clear_has_priunits() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void File::clear_priunits() {
  priunits_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_priunits();
}
inline const ::std::string& File::priunits() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.priUnits)
  return priunits_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_priunits(const ::std::string& value) {
  set_has_priunits();
  priunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.priUnits)
}
inline void File::set_priunits(const char* value) {
  set_has_priunits();
  priunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.priUnits)
}
inline void File::set_priunits(const char* value, size_t size) {
  set_has_priunits();
  priunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.priUnits)
}
inline ::std::string* File::mutable_priunits() {
  set_has_priunits();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.priUnits)
  return priunits_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_priunits() {
  // @@protoc_insertion_point(field_release:gnuradar.File.priUnits)
  clear_has_priunits();
  return priunits_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_priunits(::std::string* priunits) {
  if (priunits != NULL) {
    set_has_priunits();
  } else {
    clear_has_priunits();
  }
  priunits_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), priunits);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.priUnits)
}

// required float txCarrier = 10;
inline bool File::has_txcarrier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void File::set_has_txcarrier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void File::clear_has_txcarrier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void File::clear_txcarrier() {
  txcarrier_ = 0;
  clear_has_txcarrier();
}
inline float File::txcarrier() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.txCarrier)
  return txcarrier_;
}
inline void File::set_txcarrier(float value) {
  set_has_txcarrier();
  txcarrier_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.txCarrier)
}

// required string organization = 11;
inline bool File::has_organization() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void File::set_has_organization() {
  _has_bits_[0] |= 0x00000400u;
}
inline void File::clear_has_organization() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void File::clear_organization() {
  organization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_organization();
}
inline const ::std::string& File::organization() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.organization)
  return organization_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_organization(const ::std::string& value) {
  set_has_organization();
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.organization)
}
inline void File::set_organization(const char* value) {
  set_has_organization();
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.organization)
}
inline void File::set_organization(const char* value, size_t size) {
  set_has_organization();
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.organization)
}
inline ::std::string* File::mutable_organization() {
  set_has_organization();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.organization)
  return organization_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_organization() {
  // @@protoc_insertion_point(field_release:gnuradar.File.organization)
  clear_has_organization();
  return organization_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_organization(::std::string* organization) {
  if (organization != NULL) {
    set_has_organization();
  } else {
    clear_has_organization();
  }
  organization_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), organization);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.organization)
}

// required string site = 12;
inline bool File::has_site() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void File::set_has_site() {
  _has_bits_[0] |= 0x00000800u;
}
inline void File::clear_has_site() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void File::clear_site() {
  site_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_site();
}
inline const ::std::string& File::site() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.site)
  return site_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_site(const ::std::string& value) {
  set_has_site();
  site_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.site)
}
inline void File::set_site(const char* value) {
  set_has_site();
  site_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.site)
}
inline void File::set_site(const char* value, size_t size) {
  set_has_site();
  site_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.site)
}
inline ::std::string* File::mutable_site() {
  set_has_site();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.site)
  return site_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_site() {
  // @@protoc_insertion_point(field_release:gnuradar.File.site)
  clear_has_site();
  return site_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_site(::std::string* site) {
  if (site != NULL) {
    set_has_site();
  } else {
    clear_has_site();
  }
  site_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), site);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.site)
}

// required string user = 13;
inline bool File::has_user() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void File::set_has_user() {
  _has_bits_[0] |= 0x00001000u;
}
inline void File::clear_has_user() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void File::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& File::user() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.user)
}
inline void File::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.user)
}
inline void File::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.user)
}
inline ::std::string* File::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_user() {
  // @@protoc_insertion_point(field_release:gnuradar.File.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.user)
}

// required string radar = 14;
inline bool File::has_radar() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void File::set_has_radar() {
  _has_bits_[0] |= 0x00002000u;
}
inline void File::clear_has_radar() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void File::clear_radar() {
  radar_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_radar();
}
inline const ::std::string& File::radar() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.radar)
  return radar_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_radar(const ::std::string& value) {
  set_has_radar();
  radar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.radar)
}
inline void File::set_radar(const char* value) {
  set_has_radar();
  radar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.radar)
}
inline void File::set_radar(const char* value, size_t size) {
  set_has_radar();
  radar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.radar)
}
inline ::std::string* File::mutable_radar() {
  set_has_radar();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.radar)
  return radar_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_radar() {
  // @@protoc_insertion_point(field_release:gnuradar.File.radar)
  clear_has_radar();
  return radar_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_radar(::std::string* radar) {
  if (radar != NULL) {
    set_has_radar();
  } else {
    clear_has_radar();
  }
  radar_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), radar);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.radar)
}

// required string receiver = 15;
inline bool File::has_receiver() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void File::set_has_receiver() {
  _has_bits_[0] |= 0x00004000u;
}
inline void File::clear_has_receiver() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void File::clear_receiver() {
  receiver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_receiver();
}
inline const ::std::string& File::receiver() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.receiver)
  return receiver_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_receiver(const ::std::string& value) {
  set_has_receiver();
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.receiver)
}
inline void File::set_receiver(const char* value) {
  set_has_receiver();
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.receiver)
}
inline void File::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.receiver)
}
inline ::std::string* File::mutable_receiver() {
  set_has_receiver();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.receiver)
  return receiver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_receiver() {
  // @@protoc_insertion_point(field_release:gnuradar.File.receiver)
  clear_has_receiver();
  return receiver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_receiver(::std::string* receiver) {
  if (receiver != NULL) {
    set_has_receiver();
  } else {
    clear_has_receiver();
  }
  receiver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiver);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.receiver)
}

// required string fpgaImage = 16;
inline bool File::has_fpgaimage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void File::set_has_fpgaimage() {
  _has_bits_[0] |= 0x00008000u;
}
inline void File::clear_has_fpgaimage() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void File::clear_fpgaimage() {
  fpgaimage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fpgaimage();
}
inline const ::std::string& File::fpgaimage() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.fpgaImage)
  return fpgaimage_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_fpgaimage(const ::std::string& value) {
  set_has_fpgaimage();
  fpgaimage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.fpgaImage)
}
inline void File::set_fpgaimage(const char* value) {
  set_has_fpgaimage();
  fpgaimage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.fpgaImage)
}
inline void File::set_fpgaimage(const char* value, size_t size) {
  set_has_fpgaimage();
  fpgaimage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.fpgaImage)
}
inline ::std::string* File::mutable_fpgaimage() {
  set_has_fpgaimage();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.fpgaImage)
  return fpgaimage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_fpgaimage() {
  // @@protoc_insertion_point(field_release:gnuradar.File.fpgaImage)
  clear_has_fpgaimage();
  return fpgaimage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_fpgaimage(::std::string* fpgaimage) {
  if (fpgaimage != NULL) {
    set_has_fpgaimage();
  } else {
    clear_has_fpgaimage();
  }
  fpgaimage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fpgaimage);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.fpgaImage)
}

// required string baseFileName = 17;
inline bool File::has_basefilename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void File::set_has_basefilename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void File::clear_has_basefilename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void File::clear_basefilename() {
  basefilename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_basefilename();
}
inline const ::std::string& File::basefilename() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.baseFileName)
  return basefilename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_basefilename(const ::std::string& value) {
  set_has_basefilename();
  basefilename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.File.baseFileName)
}
inline void File::set_basefilename(const char* value) {
  set_has_basefilename();
  basefilename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.File.baseFileName)
}
inline void File::set_basefilename(const char* value, size_t size) {
  set_has_basefilename();
  basefilename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.baseFileName)
}
inline ::std::string* File::mutable_basefilename() {
  set_has_basefilename();
  // @@protoc_insertion_point(field_mutable:gnuradar.File.baseFileName)
  return basefilename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_basefilename() {
  // @@protoc_insertion_point(field_release:gnuradar.File.baseFileName)
  clear_has_basefilename();
  return basefilename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_basefilename(::std::string* basefilename) {
  if (basefilename != NULL) {
    set_has_basefilename();
  } else {
    clear_has_basefilename();
  }
  basefilename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), basefilename);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.baseFileName)
}

// optional float outputRate = 18;
inline bool File::has_outputrate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void File::set_has_outputrate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void File::clear_has_outputrate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void File::clear_outputrate() {
  outputrate_ = 0;
  clear_has_outputrate();
}
inline float File::outputrate() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.outputRate)
  return outputrate_;
}
inline void File::set_outputrate(float value) {
  set_has_outputrate();
  outputrate_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.outputRate)
}

// repeated .gnuradar.Channel channel = 19;
inline int File::channel_size() const {
  return channel_.size();
}
inline void File::clear_channel() {
  channel_.Clear();
}
inline const ::gnuradar::Channel& File::channel(int index) const {
  // @@protoc_insertion_point(field_get:gnuradar.File.channel)
  return channel_.Get(index);
}
inline ::gnuradar::Channel* File::mutable_channel(int index) {
  // @@protoc_insertion_point(field_mutable:gnuradar.File.channel)
  return channel_.Mutable(index);
}
inline ::gnuradar::Channel* File::add_channel() {
  // @@protoc_insertion_point(field_add:gnuradar.File.channel)
  return channel_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >*
File::mutable_channel() {
  // @@protoc_insertion_point(field_mutable_list:gnuradar.File.channel)
  return &channel_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >&
File::channel() const {
  // @@protoc_insertion_point(field_list:gnuradar.File.channel)
  return channel_;
}

// repeated .gnuradar.Window window = 20;
inline int File::window_size() const {
  return window_.size();
}
inline void File::clear_window() {
  window_.Clear();
}
inline const ::gnuradar::Window& File::window(int index) const {
  // @@protoc_insertion_point(field_get:gnuradar.File.window)
  return window_.Get(index);
}
inline ::gnuradar::Window* File::mutable_window(int index) {
  // @@protoc_insertion_point(field_mutable:gnuradar.File.window)
  return window_.Mutable(index);
}
inline ::gnuradar::Window* File::add_window() {
  // @@protoc_insertion_point(field_add:gnuradar.File.window)
  return window_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >*
File::mutable_window() {
  // @@protoc_insertion_point(field_mutable_list:gnuradar.File.window)
  return &window_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >&
File::window() const {
  // @@protoc_insertion_point(field_list:gnuradar.File.window)
  return window_;
}

// optional .gnuradar.RadarParameters radarParameters = 21;
inline bool File::has_radarparameters() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void File::set_has_radarparameters() {
  _has_bits_[0] |= 0x00100000u;
}
inline void File::clear_has_radarparameters() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void File::clear_radarparameters() {
  if (radarparameters_ != NULL) radarparameters_->::gnuradar::RadarParameters::Clear();
  clear_has_radarparameters();
}
inline const ::gnuradar::RadarParameters& File::radarparameters() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.radarParameters)
  return radarparameters_ != NULL ? *radarparameters_ : *default_instance_->radarparameters_;
}
inline ::gnuradar::RadarParameters* File::mutable_radarparameters() {
  set_has_radarparameters();
  if (radarparameters_ == NULL) {
    radarparameters_ = new ::gnuradar::RadarParameters;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.radarParameters)
  return radarparameters_;
}
inline ::gnuradar::RadarParameters* File::release_radarparameters() {
  // @@protoc_insertion_point(field_release:gnuradar.File.radarParameters)
  clear_has_radarparameters();
  ::gnuradar::RadarParameters* temp = radarparameters_;
  radarparameters_ = NULL;
  return temp;
}
inline void File::set_allocated_radarparameters(::gnuradar::RadarParameters* radarparameters) {
  delete radarparameters_;
  radarparameters_ = radarparameters;
  if (radarparameters) {
    set_has_radarparameters();
  } else {
    clear_has_radarparameters();
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.radarParameters)
}

// -------------------------------------------------------------------

// Channel

// required float frequency = 1;
inline bool Channel::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline float Channel::frequency() const {
  // @@protoc_insertion_point(field_get:gnuradar.Channel.frequency)
  return frequency_;
}
inline void Channel::set_frequency(float value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Channel.frequency)
}

// required string frequencyUnits = 2;
inline bool Channel::has_frequencyunits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Channel::set_has_frequencyunits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Channel::clear_has_frequencyunits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Channel::clear_frequencyunits() {
  frequencyunits_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_frequencyunits();
}
inline const ::std::string& Channel::frequencyunits() const {
  // @@protoc_insertion_point(field_get:gnuradar.Channel.frequencyUnits)
  return frequencyunits_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_frequencyunits(const ::std::string& value) {
  set_has_frequencyunits();
  frequencyunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.Channel.frequencyUnits)
}
inline void Channel::set_frequencyunits(const char* value) {
  set_has_frequencyunits();
  frequencyunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.Channel.frequencyUnits)
}
inline void Channel::set_frequencyunits(const char* value, size_t size) {
  set_has_frequencyunits();
  frequencyunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.Channel.frequencyUnits)
}
inline ::std::string* Channel::mutable_frequencyunits() {
  set_has_frequencyunits();
  // @@protoc_insertion_point(field_mutable:gnuradar.Channel.frequencyUnits)
  return frequencyunits_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_frequencyunits() {
  // @@protoc_insertion_point(field_release:gnuradar.Channel.frequencyUnits)
  clear_has_frequencyunits();
  return frequencyunits_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_frequencyunits(::std::string* frequencyunits) {
  if (frequencyunits != NULL) {
    set_has_frequencyunits();
  } else {
    clear_has_frequencyunits();
  }
  frequencyunits_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frequencyunits);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.Channel.frequencyUnits)
}

// required float phase = 3;
inline bool Channel::has_phase() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Channel::set_has_phase() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Channel::clear_has_phase() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Channel::clear_phase() {
  phase_ = 0;
  clear_has_phase();
}
inline float Channel::phase() const {
  // @@protoc_insertion_point(field_get:gnuradar.Channel.phase)
  return phase_;
}
inline void Channel::set_phase(float value) {
  set_has_phase();
  phase_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Channel.phase)
}

// required string phaseUnits = 4;
inline bool Channel::has_phaseunits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Channel::set_has_phaseunits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Channel::clear_has_phaseunits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Channel::clear_phaseunits() {
  phaseunits_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_phaseunits();
}
inline const ::std::string& Channel::phaseunits() const {
  // @@protoc_insertion_point(field_get:gnuradar.Channel.phaseUnits)
  return phaseunits_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_phaseunits(const ::std::string& value) {
  set_has_phaseunits();
  phaseunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.Channel.phaseUnits)
}
inline void Channel::set_phaseunits(const char* value) {
  set_has_phaseunits();
  phaseunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.Channel.phaseUnits)
}
inline void Channel::set_phaseunits(const char* value, size_t size) {
  set_has_phaseunits();
  phaseunits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.Channel.phaseUnits)
}
inline ::std::string* Channel::mutable_phaseunits() {
  set_has_phaseunits();
  // @@protoc_insertion_point(field_mutable:gnuradar.Channel.phaseUnits)
  return phaseunits_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_phaseunits() {
  // @@protoc_insertion_point(field_release:gnuradar.Channel.phaseUnits)
  clear_has_phaseunits();
  return phaseunits_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_phaseunits(::std::string* phaseunits) {
  if (phaseunits != NULL) {
    set_has_phaseunits();
  } else {
    clear_has_phaseunits();
  }
  phaseunits_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phaseunits);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.Channel.phaseUnits)
}

// -------------------------------------------------------------------

// Window

// required string name = 1;
inline bool Window::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Window::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Window::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Window::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Window::name() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Window::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.Window.name)
}
inline void Window::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.Window.name)
}
inline void Window::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.Window.name)
}
inline ::std::string* Window::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:gnuradar.Window.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Window::release_name() {
  // @@protoc_insertion_point(field_release:gnuradar.Window.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Window::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.Window.name)
}

// required float start = 2;
inline bool Window::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Window::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Window::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Window::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline float Window::start() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.start)
  return start_;
}
inline void Window::set_start(float value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Window.start)
}

// required float stop = 3;
inline bool Window::has_stop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Window::set_has_stop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Window::clear_has_stop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Window::clear_stop() {
  stop_ = 0;
  clear_has_stop();
}
inline float Window::stop() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.stop)
  return stop_;
}
inline void Window::set_stop(float value) {
  set_has_stop();
  stop_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Window.stop)
}

// optional float width = 4;
inline bool Window::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Window::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Window::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Window::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float Window::width() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.width)
  return width_;
}
inline void Window::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Window.width)
}

// required string units = 5;
inline bool Window::has_units() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Window::set_has_units() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Window::clear_has_units() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Window::clear_units() {
  units_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_units();
}
inline const ::std::string& Window::units() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.units)
  return units_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Window::set_units(const ::std::string& value) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gnuradar.Window.units)
}
inline void Window::set_units(const char* value) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gnuradar.Window.units)
}
inline void Window::set_units(const char* value, size_t size) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gnuradar.Window.units)
}
inline ::std::string* Window::mutable_units() {
  set_has_units();
  // @@protoc_insertion_point(field_mutable:gnuradar.Window.units)
  return units_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Window::release_units() {
  // @@protoc_insertion_point(field_release:gnuradar.Window.units)
  clear_has_units();
  return units_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Window::set_allocated_units(::std::string* units) {
  if (units != NULL) {
    set_has_units();
  } else {
    clear_has_units();
  }
  units_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), units);
  // @@protoc_insertion_point(field_set_allocated:gnuradar.Window.units)
}

// -------------------------------------------------------------------

// RadarParameters

// required int32 samplesPerPri = 1;
inline bool RadarParameters::has_samplesperpri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadarParameters::set_has_samplesperpri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadarParameters::clear_has_samplesperpri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadarParameters::clear_samplesperpri() {
  samplesperpri_ = 0;
  clear_has_samplesperpri();
}
inline ::google::protobuf::int32 RadarParameters::samplesperpri() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.samplesPerPri)
  return samplesperpri_;
}
inline void RadarParameters::set_samplesperpri(::google::protobuf::int32 value) {
  set_has_samplesperpri();
  samplesperpri_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.samplesPerPri)
}

// required int32 samplesPerBuffer = 2;
inline bool RadarParameters::has_samplesperbuffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadarParameters::set_has_samplesperbuffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadarParameters::clear_has_samplesperbuffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadarParameters::clear_samplesperbuffer() {
  samplesperbuffer_ = 0;
  clear_has_samplesperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::samplesperbuffer() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.samplesPerBuffer)
  return samplesperbuffer_;
}
inline void RadarParameters::set_samplesperbuffer(::google::protobuf::int32 value) {
  set_has_samplesperbuffer();
  samplesperbuffer_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.samplesPerBuffer)
}

// required int32 bytesPerBuffer = 3;
inline bool RadarParameters::has_bytesperbuffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadarParameters::set_has_bytesperbuffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadarParameters::clear_has_bytesperbuffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadarParameters::clear_bytesperbuffer() {
  bytesperbuffer_ = 0;
  clear_has_bytesperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::bytesperbuffer() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.bytesPerBuffer)
  return bytesperbuffer_;
}
inline void RadarParameters::set_bytesperbuffer(::google::protobuf::int32 value) {
  set_has_bytesperbuffer();
  bytesperbuffer_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.bytesPerBuffer)
}

// required float bytesPerSecond = 4;
inline bool RadarParameters::has_bytespersecond() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadarParameters::set_has_bytespersecond() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadarParameters::clear_has_bytespersecond() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadarParameters::clear_bytespersecond() {
  bytespersecond_ = 0;
  clear_has_bytespersecond();
}
inline float RadarParameters::bytespersecond() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.bytesPerSecond)
  return bytespersecond_;
}
inline void RadarParameters::set_bytespersecond(float value) {
  set_has_bytespersecond();
  bytespersecond_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.bytesPerSecond)
}

// required float pri = 5;
inline bool RadarParameters::has_pri() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RadarParameters::set_has_pri() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RadarParameters::clear_has_pri() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RadarParameters::clear_pri() {
  pri_ = 0;
  clear_has_pri();
}
inline float RadarParameters::pri() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.pri)
  return pri_;
}
inline void RadarParameters::set_pri(float value) {
  set_has_pri();
  pri_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.pri)
}

// required float prf = 6;
inline bool RadarParameters::has_prf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RadarParameters::set_has_prf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RadarParameters::clear_has_prf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RadarParameters::clear_prf() {
  prf_ = 0;
  clear_has_prf();
}
inline float RadarParameters::prf() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.prf)
  return prf_;
}
inline void RadarParameters::set_prf(float value) {
  set_has_prf();
  prf_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.prf)
}

// required int32 prisPerBuffer = 7;
inline bool RadarParameters::has_prisperbuffer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RadarParameters::set_has_prisperbuffer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RadarParameters::clear_has_prisperbuffer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RadarParameters::clear_prisperbuffer() {
  prisperbuffer_ = 0;
  clear_has_prisperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::prisperbuffer() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.prisPerBuffer)
  return prisperbuffer_;
}
inline void RadarParameters::set_prisperbuffer(::google::protobuf::int32 value) {
  set_has_prisperbuffer();
  prisperbuffer_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.prisPerBuffer)
}

// required int32 bytesPerSample = 8;
inline bool RadarParameters::has_bytespersample() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RadarParameters::set_has_bytespersample() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RadarParameters::clear_has_bytespersample() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RadarParameters::clear_bytespersample() {
  bytespersample_ = 0;
  clear_has_bytespersample();
}
inline ::google::protobuf::int32 RadarParameters::bytespersample() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.bytesPerSample)
  return bytespersample_;
}
inline void RadarParameters::set_bytespersample(::google::protobuf::int32 value) {
  set_has_bytespersample();
  bytespersample_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.bytesPerSample)
}

// required float secondsPerBuffer = 9;
inline bool RadarParameters::has_secondsperbuffer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RadarParameters::set_has_secondsperbuffer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RadarParameters::clear_has_secondsperbuffer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RadarParameters::clear_secondsperbuffer() {
  secondsperbuffer_ = 0;
  clear_has_secondsperbuffer();
}
inline float RadarParameters::secondsperbuffer() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.secondsPerBuffer)
  return secondsperbuffer_;
}
inline void RadarParameters::set_secondsperbuffer(float value) {
  set_has_secondsperbuffer();
  secondsperbuffer_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.secondsPerBuffer)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gnuradar

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Control_2eproto__INCLUDED
